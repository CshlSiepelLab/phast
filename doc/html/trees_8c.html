<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PHAST: trees.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000002.html">lib</a>&nbsp;/&nbsp;<a class="el" href="dir_000007.html">phylo</a></div>
<h1>trees.c File Reference</h1>Functions for manipulating phylogenetic trees. <a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="trees.c::tr_new_from_file"></a>
TreeNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a5">tr_new_from_file</a> (FILE *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a tree from a file in Newick (New Hampshire) format. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6" doxytag="trees.c::tr_new_from_string"></a>
TreeNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a6">tr_new_from_string</a> (char *treestr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a Newick-formatted tree from a character string. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a10" doxytag="trees.c::tr_print"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a10">tr_print</a> (FILE *f, TreeNode *root, int show_branch_lengths)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print tree in New Hampshire format. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a12" doxytag="trees.c::tr_free"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a12">tr_free</a> (TreeNode *tree)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory for tree. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a14" doxytag="trees.c::tr_cpy"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a14">tr_cpy</a> (TreeNode *dest, TreeNode *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy tree. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a15" doxytag="trees.c::tr_create_copy"></a>
TreeNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a15">tr_create_copy</a> (TreeNode *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new tree that's a copy of another one. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a17">tr_print_ordered</a> (FILE *f, TreeNode *root, int show_branch_lengths)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print tree in Newick format.  <a href="#a17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structlst__struct.html">List</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a19">tr_preorder</a> (TreeNode *tr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a list representing a preorder traversal of the tree.  <a href="#a19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structlst__struct.html">List</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a20">tr_inorder</a> (TreeNode *tr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a list representing an in-order traversal of the tree.  <a href="#a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structlst__struct.html">List</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a21">tr_postorder</a> (TreeNode *tr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a list representing a postorder traversal of the tree.  <a href="#a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a22">tr_layout_xy</a> (TreeNode *tree, int x0, int y0, int x1, int y1, int *x, int *y, int use_branch_lens, int horizontal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide x-y coordinates for layout.  <a href="#a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a23">tr_print_ps</a> (FILE *F, TreeNode *tree, int show_branch_lens, int square_branches, int use_branch_lens, int horizontal_layout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a (very basic!) postscript rendering of a tree.  <a href="#a23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a24" doxytag="trees.c::tr_total_len"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a24">tr_total_len</a> (TreeNode *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute and return sum of lengths at all edges. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a25" doxytag="trees.c::tr_total_len_subtree"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a25">tr_total_len_subtree</a> (TreeNode *sub_root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute and return sum of lengths of edges in subtree below given node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a26" doxytag="trees.c::tr_get_node"></a>
TreeNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a26">tr_get_node</a> (TreeNode *t, char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return node having specified name or NULL if none found. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a27" doxytag="trees.c::tr_scale"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a27">tr_scale</a> (TreeNode *t, double scale_const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale all branch lengths by constant factor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a28" doxytag="trees.c::tr_scale_subtree"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a28">tr_scale_subtree</a> (TreeNode *t, TreeNode *sub, double scale_const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale all branch lengths by constant factor in subtree beneath given node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a29">tr_prune</a> (TreeNode **t, <a class="el" href="structlst__struct.html">List</a> *names, int all_but)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prune away all leaves whose names are in (or not in) the specified list.  <a href="#a29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TreeNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a30">tr_lca</a> (TreeNode *tree, <a class="el" href="structlst__struct.html">List</a> *names)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the LCA of the given species.  <a href="#a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TreeNode *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a31">tr_hybrid</a> (TreeNode *sub, TreeNode *super)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given two trees, one of which is a (proper) subtree of the other, create a hybrid tree composed of the smaller tree and a scaled version of the larger tree.  <a href="#a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a33">tr_partition_leaves</a> (TreeNode *tree, TreeNode *sub, <a class="el" href="structlst__struct.html">List</a> *inside, <a class="el" href="structlst__struct.html">List</a> *outside)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Partition leaves of tree at (branch above) given node.  <a href="#a33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a34" doxytag="trees.c::tr_partition_nodes"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a34">tr_partition_nodes</a> (TreeNode *tree, TreeNode *sub, <a class="el" href="structlst__struct.html">List</a> *inside, <a class="el" href="structlst__struct.html">List</a> *outside)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to above, but partition all nodes; if either 'inside' or 'outside' is NULL, it will be ignored. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a35" doxytag="trees.c::tr_leaf_names"></a>
<a class="el" href="structlst__struct.html">List</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a35">tr_leaf_names</a> (TreeNode *tree)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a list of the leaf names in a given tree. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a37" doxytag="trees.c::tr_print_nodes"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a37">tr_print_nodes</a> (FILE *F, TreeNode *tree)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print verbose description of each node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a38">tr_reroot</a> (TreeNode *tree, TreeNode *selected_node, int include_branch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reroot tree.  <a href="#a38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a39" doxytag="trees.c::tr_in_subtree"></a>
int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="trees_8c.html#a39">tr_in_subtree</a> (TreeNode *t, TreeNode *sub)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an array indicating whether each node is in the designated subtree. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Functions for manipulating phylogenetic trees. 
<p>
Includes functions for reading, writing, traversing, and printing. Trees are represented as rooted binary trees with non-negative real branch lengths.<hr><h2>Function Documentation</h2>
<a class="anchor" name="a31" doxytag="trees.c::tr_hybrid"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">TreeNode* tr_hybrid           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TreeNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>sub</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>TreeNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>super</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Given two trees, one of which is a (proper) subtree of the other, create a hybrid tree composed of the smaller tree and a scaled version of the larger tree. 
<p>
First, a copy of the larger tree will be created and scaled such that the total branch length in the subtree in question is equal to the total branch length of the smaller tree. Then, (a copy of) the smaller tree will be used in place of the overlapping subtree in the larger tree. This function can be used to extrapolate from a small phylogeny for which accurate branch length estimation is possible (e.g., of eutherian mammals) to a larger phylogeny for which approximate branch length proportions are available, but absolute branch length estimates are not (e.g., of more distant vertebrates).     </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="trees.c::tr_inorder"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structlst__struct.html">List</a>* tr_inorder           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TreeNode *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Obtain a list representing an in-order traversal of the tree. 
<p>
Allows for simplified loops (no stacks!) and improved efficiency     </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="trees.c::tr_layout_xy"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void tr_layout_xy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TreeNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>x0</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y0</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>x1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>use_branch_lens</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>horizontal</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Provide x-y coordinates for layout. 
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>x0</em>&nbsp;</td><td>
Upper left x bound </td></tr>
<tr><td valign="top"><em>y0</em>&nbsp;</td><td>
Upper left y bound </td></tr>
<tr><td valign="top"><em>x1</em>&nbsp;</td><td>
Lower right x bound </td></tr>
<tr><td valign="top"><em>y1</em>&nbsp;</td><td>
Lower right y bound </td></tr>
<tr><td valign="top"><em>x</em>&nbsp;</td><td>
On return, will contain x-coordinates for nodes, in order of tree-&gt;nodes. Must be preallocated. </td></tr>
<tr><td valign="top"><em>y</em>&nbsp;</td><td>
On return, will contain y-coordinates for nodes, in order of tree-&gt;nodes. Must be preallocated. </td></tr>
<tr><td valign="top"><em>use_branch_lens</em>&nbsp;</td><td>
If TRUE, tree will be laid out such that edges are proportional to branch lengths (dparent attributes) </td></tr>
<tr><td valign="top"><em>horizontal</em>&nbsp;</td><td>
If TRUE, tree will be laid out with root on left and leaves on right; otherwise, root will be at top and leaves at bottom </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="trees.c::tr_lca"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">TreeNode* tr_lca           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TreeNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structlst__struct.html">List</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>names</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the LCA of the given species. 
<p>
Assumes ids are numbered in preorder (a node's parent always has a smaller id than it does and left descendants have smaller ids than right descendants).     </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="trees.c::tr_partition_leaves"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void tr_partition_leaves           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TreeNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>TreeNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>sub</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structlst__struct.html">List</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>inside</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structlst__struct.html">List</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>outside</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Partition leaves of tree at (branch above) given node. 
<p>
All descendant leaves of 'sub' will be added to 'inside' list and all non-descendants will be added to 'outside' list. Lists must be pre-allocated.     </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="trees.c::tr_postorder"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structlst__struct.html">List</a>* tr_postorder           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TreeNode *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Obtain a list representing a postorder traversal of the tree. 
<p>
Allows for simplified loops (no stacks!) and improved efficiency     </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="trees.c::tr_preorder"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structlst__struct.html">List</a>* tr_preorder           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TreeNode *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Obtain a list representing a preorder traversal of the tree. 
<p>
Allows for simplified loops (no stacks!) and improved efficiency     </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="trees.c::tr_print_ordered"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void tr_print_ordered           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>TreeNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>show_branch_lengths</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print tree in Newick format. 
<p>
This version imposes an ordering on the leaves (useful when comparing trees that have been rearranged). At every internal node, we store the name of the leaf beneath it that comes first alphanumerically. When recursively printing the tree, at each internal node, we call its children in the order of these names.     </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="trees.c::tr_print_ps"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void tr_print_ps           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>F</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>TreeNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>show_branch_lens</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>square_branches</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>use_branch_lens</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>horizontal_layout</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print a (very basic!) postscript rendering of a tree. 
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>F</em>&nbsp;</td><td>
Destination file </td></tr>
<tr><td valign="top"><em>tree</em>&nbsp;</td><td>
Tree root </td></tr>
<tr><td valign="top"><em>show_branch_lens</em>&nbsp;</td><td>
Whether to print branch lengths by edges </td></tr>
<tr><td valign="top"><em>square_branches</em>&nbsp;</td><td>
If TRUE, branches will be right-angled, otherwise will be diagonal </td></tr>
<tr><td valign="top"><em>use_branch_lens</em>&nbsp;</td><td>
If TRUE, tree will be laid out such that edges are proportional to branch lengths (dparent attributes) </td></tr>
<tr><td valign="top"><em>horizontal_layout</em>&nbsp;</td><td>
If TRUE, tree will be laid out with root on left and leaves on right; otherwise, root will be at top and leaves at bottom </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="trees.c::tr_prune"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void tr_prune           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TreeNode **&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structlst__struct.html">List</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>all_but</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prune away all leaves whose names are in (or not in) the specified list. 
<p>
Nodes will be removed and branches combined (branch lengths added) to restore as a proper binary tree. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>t</em>&nbsp;</td><td>
Tree to prune (may be altered because root can change) </td></tr>
<tr><td valign="top"><em>names</em>&nbsp;</td><td>
List of names. On return, will contain list of names of leaves that were pruned away. </td></tr>
<tr><td valign="top"><em>all_but</em>&nbsp;</td><td>
if FALSE, prune leaves *in* 'names'; if TRUE, prune leaves *not in* 'names' </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="trees.c::tr_reroot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void tr_reroot           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TreeNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>TreeNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>selected_node</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>include_branch</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reroot tree. 
<p>
Subtree originally beneath selected node will become right subtree of root, and remainder of tree will be left subtree. If include_branch == FALSE, the selected node will become the new root, and a zero-length branch to its right will connect it to its original subtree. If instead include_branch == TRUE, then the branch above the selected node will also be included in the right subtree. In this case, the selected node will become the right child of the new root and the branch in question will become the right branch beneath the new root. The left branch beneath the new root will have length zero and will connect to the former parent of the selected node. Warning: ids will not be altered, so they will no longer be consistent with a preorder traversal of the tree     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Wed Oct 11 16:34:18 2006 for PHAST by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
