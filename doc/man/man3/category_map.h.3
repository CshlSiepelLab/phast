category_map.h File Reference.TH "category_map.h" 3 "11 Oct 2006" "Version v0.9b" "PHAST" \" -*- nroff -*-
.ad l
.nh
.SH NAME
category_map.h \- Mapping between feature types and site categories. 
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBUnspooler\fP"
.br
.RI "\fIAllows 'unspooling' of \fBCategoryMap\fP, i.e., a mapping from the original categories to a larger set that allows for categories to be 'conditioned on' other categories. \fP"
.ti -1c
.RI "struct \fBCategoryRange\fP"
.br
.RI "\fIRepresents range of categories for a given type. \fP"
.ti -1c
.RI "struct \fBCategoryMap\fP"
.br
.RI "\fICategory map object. \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBBACKGD_CAT_NAME\fP   'background'"
.br
.RI "\fIName of background category. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBCategoryMap\fP * \fBcm_create_trivial\fP (int ncats, char *feature_prefix)"
.br
.RI "\fICreate a trivial \fBCategoryMap\fP, with feature types equal to category numbers (plus an optional prefix) and ranges all of size one. \fP"
.ti -1c
.RI "\fBCategoryMap\fP * \fBcm_new_from_features\fP (\fBGFF_Set\fP *feats)"
.br
.RI "\fICreate a category map with a category for each feature type in a \fBGFF_Set\fP. \fP"
.ti -1c
.RI "\fBCategoryMap\fP * \fBcm_new_string_or_file\fP (char *optarg)"
.br
.RI "\fICreate a new category map from a string that can either be a filename or a brief 'inlined' category map, e.g., 'NCATS = 3 ; CDS 1-3'. \fP"
.ti -1c
.RI "void \fBcm_realloc\fP (\fBCategoryMap\fP *cm, int ncats)"
.br
.RI "\fIReallocate a category map to allow for the specified size. \fP"
.ti -1c
.RI "void \fBcm_free\fP (\fBCategoryMap\fP *cm)"
.br
.RI "\fIFree memory associated with category map. \fP"
.ti -1c
.RI "\fBCategoryMap\fP * \fBcm_read\fP (FILE *F)"
.br
.RI "\fIRead a \fBCategoryMap\fP from a file. \fP"
.ti -1c
.RI "int \fBcm_get_category\fP (\fBCategoryMap\fP *cm, String *type)"
.br
.RI "\fIReturn the 'base' category for a given feature type (first category in range). \fP"
.ti -1c
.RI "\fBList\fP * \fBcm_get_category_list\fP (\fBCategoryMap\fP *cm, \fBList\fP *names, int ignore_missing)"
.br
.RI "\fIReturn a list of category numbers corresponding to a given list of category names and or numbers. \fP"
.ti -1c
.RI "String * \fBcm_get_feature\fP (\fBCategoryMap\fP *cm, int cat)"
.br
.RI "\fIRetrieve the (primary) feature type associated with the specified category number. \fP"
.ti -1c
.RI "String * \fBcm_get_feature_unique\fP (\fBCategoryMap\fP *cm, int cat)"
.br
.RI "\fIObtain a unique name based on the (primary) feature type associated with the specified category number. \fP"
.ti -1c
.RI "void \fBcm_print\fP (\fBCategoryMap\fP *cm, FILE *F)"
.br
.RI "\fIPrint a \fBCategoryMap\fP to a file. \fP"
.ti -1c
.RI "void \fBcm_add_feature_type\fP (\fBCategoryMap\fP *cm, String *type, int cycle_size)"
.br
.RI "\fIAdd new feature to \fBCategoryMap\fP. \fP"
.ti -1c
.RI "\fBGFF_Set\fP * \fBcm_labeling_as_gff\fP (\fBCategoryMap\fP *cm, int *path, int length, int *path_to_cat, int *reverse_compl, char *seqname, char *source, \fBList\fP *frame_cats, char *grouproot, char *idpref)"
.br
.RI "\fICreate a \fBGFF_Set\fP from a sequence of category/state numbers, using a specified category map and mapping from raw state numbers to category numbers. \fP"
.ti -1c
.RI "void \fBcm_spooled_to_unspooled\fP (\fBCategoryMap\fP *cm, int *path, int pathlen)"
.br
.RI "\fImaps a sequence (array) of category numbers from the spooled space to the unspooled space, using the current unspooler. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Mapping between feature types and site categories. 

Category maps allow arbitrary 'features' (e.g., CDSs, UTRs, introns, ancestral repeats, CpG islands), as specified in an annotations file (e.g., GFF or BED), to be mapped to numbered site 'categories' which can be treated separately in various analyses. They also allow a mapping backwards from site categories to features. Given a category map and a set of annotations, the sites of an alignment can unambiguously be labeled by category, and conversely, given a category map and an alignment whose sites are labeled by category, a set of annotations can be produced unambiguously.
.PP
Category maps work as follows. Each feature is defined by a 'type' (a string), and each category by an integer. Category numbers must run consecutively from 1 to the total number of categories (but they need not be defined in order). Categories fall into 'category ranges', each of which spans a sequence of consecutive integers. A 'simple' feature type has a category range of size one, and a 'cyclic' feature type has a range of size greater than one. Multiple types may map to the same category number, but if they are cyclic, the ranges must coincide exactly. The mapping from feature types to category numbers is unambiguous. To allow mapping in the other direction, however, one type associated with a given category is designated as 'primary'. By convention, the first type to be defined is considered the primary type. Category 0 is reserved as the 'background' or 'default' category (all other categories stand in relief to this category).
.PP
The system is best understood by considering an example of a category file:
.PP
.PP
.nf

   NCATS = 6
.fi
.PP
.PP
.PP
.nf
   CDS         1-3
   intron      4
   5'UTR       5
   3'UTR       6
   start_codon 1-3
   stop_codon  1-3
   5'splice    4       
   3'splice    4
   
.fi
.PP
.PP
The NCATS line must appear first; it defines the number of categories. Blank lines are ignored throughout. The remaining lines define category ranges. Each one must have two or three columns separated by whitespace. The first column gives the feature type and the second the range of category numbers. Strings of the form 'a-b' indicate cyclic feature types, and single integers indicate simple feature types. Here CDS, start_codon, and stop_codon are cyclic feature types, mapped to the same range, 1-3 (CDS is the primary feature type). The others are all simple types.
.PP
This example illustrates how a category map can be used to 'project' a relatively large set of features onto a small set of categories. It's sometimes useful to generate an extensive set of annotations, then to have multiple category maps that 'collapse' categories in various ways. For example, suppose we wanted to collapse the features above even further, to consider just coding and noncoding sites. We could use:
.PP
.PP
.nf

   NCATS = 1
.fi
.PP
.PP
.PP
.nf
   CDS         1
   start_codon 1
   stop_codon  1
   
.fi
.PP
.PP
Here we take advantage of the fact that all undefined feature types will map to the 'background' category (category 0).
.SH "Function Documentation"
.PP 
.SS "void cm_add_feature_type (\fBCategoryMap\fP * cm, String * type, int cycle_size)"
.PP
Add new feature to \fBCategoryMap\fP. 
.PP
Assumes a feature of the specified type does not already exist. 
.SS "int cm_get_category (\fBCategoryMap\fP * cm, String * type)"
.PP
Return the 'base' category for a given feature type (first category in range). 
.PP
Returns 0 (background) if no match. 
.SS "\fBList\fP* cm_get_category_list (\fBCategoryMap\fP * cm, \fBList\fP * names, int ignore_missing)"
.PP
Return a list of category numbers corresponding to a given list of category names and or numbers. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIcm\fP\fP
\fBCategoryMap\fP object. May be NULL if categories are specified by number rather than by name. (In that case, this function will reduce to conversion of strings to integers.) 
.TP
\fB\fInames\fP\fP
List of categories. May be specified by name or number (useful when accepting input from users) 
.TP
\fB\fIignore_missing\fP\fP
Whether to ignore unrecognized types. If FALSE, then function will abort when it encounters an unrecognized type. 
.SS "String* cm_get_feature (\fBCategoryMap\fP * cm, int cat)"
.PP
Retrieve the (primary) feature type associated with the specified category number. 
.PP
Note: return value is passed by reference -- do not alter. 
.SS "String* cm_get_feature_unique (\fBCategoryMap\fP * cm, int cat)"
.PP
Obtain a unique name based on the (primary) feature type associated with the specified category number. 
.PP
Returns a pointer to a newly allocated String. 
.SS "\fBGFF_Set\fP* cm_labeling_as_gff (\fBCategoryMap\fP * cm, int * path, int length, int * path_to_cat, int * reverse_compl, char * seqname, char * source, \fBList\fP * frame_cats, char * grouproot, char * idpref)"
.PP
Create a \fBGFF_Set\fP from a sequence of category/state numbers, using a specified category map and mapping from raw state numbers to category numbers. 
.PP
\fBParameters: \fP
.in +1c
.TP
\fB\fIcm\fP\fP
\fBCategoryMap\fP to use in mapping 
.TP
\fB\fIpath\fP\fP
Raw sequence of state/category numbers 
.TP
\fB\fIlength\fP\fP
Length of sequence 
.TP
\fB\fIpath_to_cat\fP\fP
Mapping from raw numbers to category numbers 
.TP
\fB\fIreverse_compl\fP\fP
Array of boolean values indicating whether each raw-sequence value corresponds to the reverse strand 
.TP
\fB\fIseqname\fP\fP
char string to use as 'seqname' in generated \fBGFF_Set\fP 
.TP
\fB\fIsource\fP\fP
char string to use as 'source' in generated \fBGFF_Set\fP 
.TP
\fB\fIframe_cats\fP\fP
Categories for which to obtain frame information (by name) 
.TP
\fB\fIgrouproot\fP\fP
Tag to use to define groups in \fBGFF_Set\fP (e.g., 'transcript_id') 
.TP
\fB\fIidpref\fP\fP
Prefix for ids of predicted elements (may be NULL). Can be used to ensure ids are unique. 
.SS "\fBCategoryMap\fP* cm_new_from_features (\fBGFF_Set\fP * feats)"
.PP
Create a category map with a category for each feature type in a \fBGFF_Set\fP. 
.PP
Category numbers are assigned in order of appearance of types 
.SS "\fBCategoryMap\fP* cm_new_string_or_file (char * optarg)"
.PP
Create a new category map from a string that can either be a filename or a brief 'inlined' category map, e.g., 'NCATS = 3 ; CDS 1-3'. 
.PP
Useful for command-line arguments. 
.SS "void cm_spooled_to_unspooled (\fBCategoryMap\fP * cm, int * path, int pathlen)"
.PP
maps a sequence (array) of category numbers from the spooled space to the unspooled space, using the current unspooler. 
.PP
Original sequence is overwritten 
.SH "Author"
.PP 
Generated automatically by Doxygen for PHAST from the source code.
